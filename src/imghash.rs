use bitvec::prelude::*;

#[derive(Debug, PartialEq)]
pub struct ImageHash {
    data: BitBox<u8, Msb0>, // Use a boxed slice to save one word
    width: u32,
    height: u32,
}

impl ImageHash {
    /// Create a new ImageHash from the specified bit matrix.
    #[deprecated(since = "1.5.0", note = "Use `ImageHash::from_stream` instead")]
    pub fn new(matrix: Vec<Vec<bool>>) -> ImageHash {
        if matrix.is_empty() || matrix.first().unwrap().is_empty() {
            panic!("Matrix cannot be empty");
        }

        // Ensures that the matrix rows all have the same length.
        // If not, this is a critical issue and likely a bug in the code
        // that creates the hash -> therefore a panic here is appropriate
        let width = matrix.first().unwrap().len();
        let height = matrix.len();

        if matrix.iter().any(|row| row.len() != width) {
            panic!("All rows must have the same length");
        }

        Self::from_stream(
            matrix.into_iter().flat_map(Vec::into_iter),
            width as u32,
            height as u32,
        )
    }

    /// Create a new ImageHash from the specified bits stream.
    pub(crate) fn from_stream(
        stream: impl IntoIterator<Item = bool>,
        width: u32,
        height: u32,
    ) -> ImageHash {
        let length = width as usize * height as usize;
        let size = (length + 7) / 8;
        let padding = size * 8 - length;

        let buf = vec![0_u8; size];
        let mut data = BitBox::from_bitslice(&buf.view_bits::<Msb0>()[padding..]);
        let mut count = 0;

        stream.into_iter().enumerate().for_each(|(i, bit)| {
            data.set(i, bit);
            count += 1;
        });

        if count != length {
            panic!("Data length does not match the specified width and height");
        }

        data.fill_uninitialized(false);

        ImageHash {
            data,
            width,
            height,
        }
    }

    /// Returns a copy of the underlying matrix that represents the [`ImageHash`].
    #[deprecated(
        since = "1.5.0",
        note = "This method is inefficient because it creates a new Vec<Vec<bool>>."
    )]
    pub fn matrix(&self) -> Vec<Vec<bool>> {
        let width = self.width as usize;

        (0..self.height as usize)
            .map(|y| {
                (0..self.width as usize)
                    .map(|x| {
                        self.data
                            .get(y * width + x)
                            .as_deref()
                            .copied()
                            .unwrap_or(false)
                    })
                    .collect::<Vec<_>>()
            })
            .collect::<Vec<_>>()
    }

    /// Flattens the bit matrix that represents the [`ImageHash`] into a single vector.
    #[deprecated(
        since = "1.5.0",
        note = "This method is inefficient because it creates a new Vec<bool>."
    )]
    pub fn flatten(&self) -> Vec<bool> {
        self.data.iter().map(|v| *v).collect()
    }

    /// The shape of the matrix that represents the [`ImageHash`]
    pub fn shape(&self) -> (usize, usize) {
        (self.height as usize, self.width as usize)
    }

    /// The hamming distance between this hash and the other hash. The hamming distance is the
    /// number of bits that differ between the two hashes.
    pub fn distance(&self, other: &ImageHash) -> Result<usize, String> {
        if self.shape() != other.shape() {
            return Err("Cannot compute distance of hashes with different sizes".to_string());
        }

        Ok(self
            .data
            .iter()
            .zip(other.data.iter())
            .take(self.width as usize * self.height as usize)
            .fold(0, |acc, (a, b)| acc + (a != b) as usize))
    }

    /// Encodes the bit matrix that represents the [`ImageHash`] into a hexadecimal string.
    /// This implementation is strictly compatible with `imagehash` package for Python.
    pub fn encode(&self) -> String {
        use std::io::Write;

        if self.width == 0 && self.height == 0 {
            panic!("Cannot encode an empty matrix")
        }

        let mut result = Vec::new();

        for byte in self.data.as_raw_slice().iter() {
            write!(&mut result, "{:02x}", byte).unwrap();
        }

        let nibbles = (self.width * self.height + 3) / 4;

        if nibbles % 2 == 1 {
            result.remove(0);
        }

        String::from_utf8(result).unwrap()
    }

    /// Decodes a hexadecimal string into a bit matrix that represents the [`ImageHash`].
    /// This implementation is strictly compatible with hashes generated by the `imagehash` package
    /// for Python (read on about the width and height parameter).
    ///
    /// The `width` and `height` parameters are used to specify the dimensions of the matrix that the
    /// hash was originally generated from. This is usually 8 x 8 in the original `imagehash` package.
    /// If you have a hash that was generated with the `imagehash` package, check what you specified for
    /// the `hash_size`-parameter when generating the hash. Use this value for the `width` and `height`.
    ///
    /// This implementation actually deviates slightly from the original imagehash package, because
    /// it allows the decoding of hashes that have been generated on non-square matrices. This is because
    /// the original package actually only allows the generation of hashes on square matrices, however this
    /// crate does allow arbitrary dimensions.
    pub fn decode(s: &str, width: u32, height: u32) -> Result<ImageHash, String> {
        // first we validate that the width and height actually make sense with the given string
        let length = width as usize * height as usize;

        // guard against too small values
        if length == 0 {
            return Err("Width or height cannot be 0".to_string());
        }

        // validate that s is a valid string
        if s.len() == 0 {
            return Err("String is empty".to_string());
        }

        // guard against a string that is too short or too long for the specified size
        let nibbles = (length + 3) / 4;

        if s.len() != nibbles {
            return Err("String is too short or too long for the specified size".to_string());
        }

        // we create a bit vector of the correct size
        let size = (length + 7) / 8;
        let padding = size * 8 - length;

        let mut data = vec![0_u8; (length + 7) / 8];

        let mut x = 0;
        let mut iter = s.chars();

        loop {
            let Some(c1) = iter.next() else {
                break;
            };

            let hex1 = c1
                .to_digit(16)
                .ok_or_else(|| "invalid digit found in string".to_string())?
                as u8;

            data[x] = if x == 0 && nibbles % 2 == 1 {
                // if the first nibble is odd, there is assumed a leading zero
                hex1
            } else {
                let Some(c2) = iter.next() else {
                    break;
                };
                hex1 * 16
                    + c2.to_digit(16)
                        .ok_or_else(|| "invalid digit found in string".to_string())?
                        as u8
            };

            x += 1;
        }

        Ok(ImageHash {
            data: BitBox::from_bitslice(&data.view_bits::<Msb0>()[padding..]),
            width,
            height,
        })
    }
}

#[cfg(test)]
mod tests {

    use super::*;

    // NEW

    #[test]
    fn test_image_hash_new_with_valid_matrix() {
        // Arrange
        let hash = ImageHash::new(vec![vec![false, true], vec![true, false]]);

        // Assert
        assert_eq!(
            hash,
            ImageHash::new(vec![vec![false, true], vec![true, false]],)
        );
    }

    #[test]
    #[should_panic]
    fn test_image_hash_new_with_invalid_matrix() {
        // should panic as the second row is longer than the first one
        let _ = ImageHash::new(vec![vec![false, true], vec![true, false, false]]);
    }

    // MATRIX

    #[test]
    fn test_image_hash_get_matrix() {
        // Arrange
        let hash = ImageHash::new(vec![vec![false, true], vec![true, false]]);

        // Assert
        assert_eq!(hash.matrix(), vec![vec![false, true], vec![true, false]],);
    }

    // FLATTEN

    #[test]
    fn test_image_hash_flatten() {
        // Arrange
        let hash = ImageHash::new(vec![vec![false, true], vec![true, false]]);

        let expected = vec![false, true, true, false];

        // Act
        let flattened = hash.flatten();

        // Assert
        assert_eq!(flattened, expected);
    }

    // SHAPE

    #[test]
    fn test_image_hash_shape() {
        // Arrange
        let hash = ImageHash::new(vec![vec![false, true], vec![true, false]]);

        let expected = (2, 2);

        // Act
        let flattened = hash.shape();

        // Assert
        assert_eq!(flattened, expected);
    }

    // ENCODING

    #[test]
    fn test_image_hash_encoding() {
        // Arrange

        // -> resulting bit str: 0010 0100 1111 0000
        // -> resulting hex str: 24F0
        let hash = ImageHash::new(vec![
            vec![false, false, true, false],
            vec![false, true, false, false],
            vec![true, true, true, true],
            vec![false, false, false, false],
        ]);

        // Assert
        assert_eq!(hash.encode(), "24f0");
    }

    #[test]
    fn test_image_hash_encoding_with_non_square_matrix() {
        // Arrange

        // -> resulting bit str: 0110 1010 0011 1110 0001
        // -> resulting hex str: 6A3E1
        let hash = ImageHash::new(vec![
            vec![false, true, true, false, true],
            vec![false, true, false, false, false],
            vec![true, true, true, true, true],
            vec![false, false, false, false, true],
        ]);

        // Assert
        assert_eq!(hash.encode(), "6a3e1");
    }

    #[test]
    fn test_image_hash_encoding_with_uneven_total_bits() {
        // Arrange

        // due to the uneven number of bits, the entire bit string gets padded until
        // it is divisible by 4
        // -> resulting bit str: 0011 0101 0001 1111
        // -> resulting hex str: 351F
        let hash = ImageHash::new(vec![
            vec![false, true, true, false, true],
            vec![false, true, false, false, false],
            vec![true, true, true, true, true],
        ]);

        // Assert
        assert_eq!(hash.encode(), "351f");
    }

    #[test]
    #[should_panic(expected = "Matrix cannot be empty")]
    fn test_image_hash_encoding_with_empty_matrix() {
        let _ = ImageHash::new(vec![]); // <- should panic
    }

    #[test]
    fn test_image_hash_python_safe_encoding_with_single_bit() {
        // Arrange

        // should equal to 1 due to added padding
        // -> resulting bit str: 0001
        // -> resulting hex str: 1
        let hash = ImageHash::new(vec![vec![true]]);

        // Assert
        assert_eq!(hash.encode(), "1");
    }

    // DECODING

    #[test]
    fn test_image_hash_decoding() {
        // Arrange
        let expected = vec![
            vec![false, false, true, false],
            vec![false, true, false, false],
            vec![true, true, true, true],
            vec![false, false, false, false],
        ];

        // Act
        let decoded = ImageHash::decode("24f0", 4, 4).unwrap();

        // Assert
        assert_eq!(decoded.matrix(), expected);
    }

    #[test]
    fn test_image_hash_decoding_with_non_square_matrix() {
        // Arrange
        let expected = vec![
            vec![false, true, true, false, true],
            vec![false, true, false, false, false],
            vec![true, true, true, true, true],
            vec![false, false, false, false, true],
        ];

        // Act
        let decoded = ImageHash::decode("6a3e1", 5, 4).unwrap();

        // Assert
        assert_eq!(decoded.matrix(), expected);
    }

    #[test]
    fn test_image_hash_decoding_with_uneven_total_bits() {
        // Arrange
        let expected = vec![
            vec![false, true, true, false, true],
            vec![false, true, false, false, false],
            vec![true, true, true, true, true],
        ];

        // Act
        let decoded = ImageHash::decode("351f", 5, 3).unwrap();

        // Assert
        assert_eq!(decoded.matrix(), expected);
    }

    #[test]
    fn test_image_hash_decoding_with_single_bit() {
        // Arrange
        let expected = vec![vec![true]];

        // Act
        let decoded = ImageHash::decode("1", 1, 1).unwrap();

        // Assert
        assert_eq!(decoded.matrix(), expected);
    }

    #[test]
    fn test_image_hash_decoding_with_too_short_string() {
        // Act
        let decoded = ImageHash::decode("AB", 2, 5);

        // Assert
        match decoded {
            Ok(_) => panic!("Should not have decoded"),
            Err(e) => assert_eq!(e, "String is too short or too long for the specified size"),
        }
    }

    #[test]
    fn test_image_hash_decoding_with_too_long_string() {
        // Act
        let decoded = ImageHash::decode("ABCD", 2, 2);

        // Assert
        match decoded {
            Ok(_) => panic!("Should not have decoded"),
            Err(e) => assert_eq!(e, "String is too short or too long for the specified size"),
        }
    }

    #[test]
    fn test_image_hash_decoding_with_invalid_string() {
        // Act
        let decoded = ImageHash::decode("!", 2, 2);

        // Assert
        match decoded {
            Ok(_) => panic!("Should not have decoded"),
            Err(e) => assert_eq!(e, "invalid digit found in string"),
        }
    }

    #[test]
    fn test_image_hash_decoding_with_zero_size_matrix() {
        // Act
        let decoded = ImageHash::decode("!", 2, 0);

        // Assert
        match decoded {
            Ok(_) => panic!("Should not have decoded"),
            Err(e) => assert_eq!(e, "Width or height cannot be 0"),
        }
    }

    #[test]
    fn test_image_hash_decoding_with_empty_string() {
        // Act
        let decoded = ImageHash::decode("", 2, 2);

        // Assert
        match decoded {
            Ok(_) => panic!("Should not have decoded"),
            Err(e) => assert_eq!(e, "String is empty"),
        }
    }

    // DISTANCE

    #[test]
    fn test_image_hash_distance_with_unequal_hashes() {
        // Arrange
        let hash1 = ImageHash::new(vec![vec![false, true], vec![true, false]]);

        let hash2 = ImageHash::new(vec![vec![true, true], vec![false, false]]);

        // Act
        let distance = hash1.distance(&hash2);

        // Assert
        match distance {
            Ok(d) => assert_eq!(d, 2),
            Err(_) => panic!("Should not have errored"),
        }
    }

    #[test]
    fn test_image_hash_distance_with_equal_hashes() {
        // Arrange
        let hash1 = ImageHash::new(vec![vec![false, true], vec![true, false]]);

        let hash2 = ImageHash::new(vec![vec![false, true], vec![true, false]]);

        // Act
        let distance = hash1.distance(&hash2);

        // Assert
        match distance {
            Ok(d) => assert_eq!(d, 0),
            Err(_) => panic!("Should not have errored"),
        }
    }

    #[test]
    fn test_image_hash_distance_with_different_sizes() {
        // Arrange
        let hash1 = ImageHash::new(vec![vec![false, true, false], vec![true, false, false]]);

        let hash2 = ImageHash::new(vec![vec![false, true], vec![true, false]]);

        // Act
        let distance = hash1.distance(&hash2);

        // Assert
        match distance {
            Ok(_) => panic!("Should not have succeeded"),
            Err(e) => assert_eq!(e, "Cannot compute distance of hashes with different sizes"),
        }
    }
}
