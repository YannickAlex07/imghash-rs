#[derive(Debug, PartialEq)]
pub struct ImageHash {
    matrix: Vec<Vec<bool>>,
}

impl ImageHash {
    /// Create a new ImageHash from the specificed bit matrix.
    pub fn new(matrix: Vec<Vec<bool>>) -> ImageHash {
        // Ensures that the matrix rows all have the same length.
        // If not, this is a critical issue and likely a bug in the code
        // that creates the hash -> therefore a panic here is appropriate
        let first_length = matrix.first().unwrap().len();
        matrix.iter().for_each(|row| {
            if row.len() != first_length {
                panic!("All rows must have the same length");
            }
        });

        ImageHash { matrix }
    }

    /// Returns a copy of the underlying matrix that represents the [`ImageHash`].
    pub fn matrix(&self) -> Vec<Vec<bool>> {
        self.matrix.clone()
    }

    /// Flattens the bit matrix that represents the [`ImageHash`] into a single vector.
    pub fn flatten(&self) -> Vec<bool> {
        self.matrix.iter().flatten().copied().collect()
    }

    /// The shape of the matrix that represents the [`ImageHash`]
    pub fn shape(&self) -> (usize, usize) {
        (self.matrix.len(), self.matrix.first().unwrap().len())
    }

    /// The hamming distance between this hash and the other hash. The hamming distance is the
    /// number of bits that differ between the two hashes.
    pub fn distance(&self, other: &ImageHash) -> Result<usize, String> {
        if self.shape() != other.shape() {
            return Err("Cannot compute distance of hashes with different sizes".to_string());
        }

        Ok(self
            .flatten()
            .iter()
            .zip(other.flatten().iter())
            .fold(0, |acc, (a, b)| acc + (a != b) as usize))
    }

    /// Encodes the bit matrix that represents the [`ImageHash`] into a hexadecimal string.
    /// This implementation is strictly compatible with `imagehash` package for Python.
    pub fn encode(&self) -> String {
        let mut result = "".to_string();

        let mut flattened = self.flatten();
        if flattened.is_empty() {
            panic!("Cannot encode an empty matrix")
        }

        // the Python package essentially pads the entire bit array with 0s
        // until it is cleanly encodable into hexadecimal characters.
        // this part essentially does the same thing.
        if flattened.len() % 4 != 0 {
            let padding = 4 - (flattened.len() % 4);

            for _ in 0..padding {
                flattened.push(false);
            }

            flattened.rotate_right(padding)
        }

        // we convert the bit array one character at a time
        for chunk in flattened.chunks(4) {
            let byte = chunk.iter().fold(0, |acc, &bit| (acc << 1) | bit as u8);
            result += &format!("{:x}", byte);
        }

        result
    }

    /// Decodes a hexadecimal string into a bit matrix that represents the [`ImageHash`].
    /// This implementation is strictly compatible with hashes generated by the `imagehash` package
    /// for Python (read on about the width and height parameter).
    ///
    /// The `width` and `height` parameters are used to specify the dimensions of the matrix that the
    /// hash was originally generated from. This is usually 8 x 8 in the original `imagehash` package.
    /// If you have a hash that was generated with the `imagehash` package, check what you specified for
    /// the `hash_size`-parameter when generating the hash. Use this value for the `width` and `height`.
    ///
    /// This implementation actually deviates slightly from the original imagehash package, because
    /// it allows the decoding of hashes that have been generated on non-square matricies. This is because
    /// the original package actually only allows the generation of hashes on square matricies, however this
    /// crate does allow arbitrary dimensions.
    pub fn decode(s: &str, width: usize, height: usize) -> Result<ImageHash, String> {
        // first we validate that the width and height actually make sense with the given string
        let total_length = width * height;

        // guard against too small values
        if total_length == 0 {
            return Err("Width or height cannot be 0".to_string());
        }

        // validate that s is a valid string
        if s.len() == 0 {
            return Err("String is empty".to_string());
        }

        // guard against a string that is too short or too long for the specified size
        match total_length % 4 {
            0 => {
                if total_length / 4 != s.len() {
                    return Err(
                        "String is too short or too long for the specified size".to_string()
                    );
                }
            }
            remainder => {
                if (total_length + (4 - remainder)) / 4 != s.len() {
                    return Err(
                        "String is too short or too long for the specified size".to_string()
                    );
                }
            }
        }

        // the encoding essentially pads the entire bit array with 0s to make
        // it encodable. Here we calculate how many bits were padded, which we can then skip
        // in the beginning.
        let mut skip = 0;
        if total_length % 4 != 0 {
            skip = 4 - ((width * height) % 4);
        }

        // we create a matrix of the correct size
        let mut bits: Vec<bool> = vec![];
        for (i, b) in s.chars().enumerate() {
            let digit = b.to_ascii_lowercase().to_digit(16);
            if digit.is_none() {
                return Err("invalid digit found in string".to_string());
            }

            // we add the necessary skip that we calculated earlier
            // for the first character
            let mut start = 0;
            if i == 0 {
                start += skip;
            }

            // goes through each of the 4 bits that makes up our hexadecimal character
            for i in start..4 {
                // we extract the bit from the digit
                let bit = (digit.unwrap() >> (3 - i)) & 1;
                bits.push(bit == 1)
            }
        }

        let matrix: Vec<Vec<bool>> = bits.chunks(width).map(|x: &[bool]| x.to_vec()).collect();

        // sanity checks
        if matrix.len() != height || matrix.last().unwrap().len() != width {
            return Err(
                "Matrix dimensions do not match the specified width and height".to_string(),
            );
        }

        Ok(ImageHash { matrix })
    }
}

#[cfg(test)]
mod tests {

    use super::*;

    // NEW

    #[test]
    fn test_image_hash_new_with_valid_matrix() {
        // Arrange
        let hash = ImageHash::new(vec![vec![false, true], vec![true, false]]);

        // Assert
        assert_eq!(
            hash,
            ImageHash {
                matrix: vec![vec![false, true], vec![true, false]],
            }
        );
    }

    #[test]
    #[should_panic]
    fn test_image_hash_new_with_invalid_matrix() {
        // should panic as the second row is longer than the first one
        let _ = ImageHash::new(vec![vec![false, true], vec![true, false, false]]);
    }

    // MATRIX

    #[test]
    fn test_image_hash_get_matrix() {
        // Arrange
        let hash = ImageHash::new(vec![vec![false, true], vec![true, false]]);

        // Assert
        assert_eq!(hash.matrix(), vec![vec![false, true], vec![true, false]],);
    }

    // FLATTEN

    #[test]
    fn test_image_hash_flatten() {
        // Arrange
        let hash = ImageHash {
            matrix: vec![vec![false, true], vec![true, false]],
        };

        let expected = vec![false, true, true, false];

        // Act
        let flattened = hash.flatten();

        // Assert
        assert_eq!(flattened, expected);
    }

    // SHAPE

    #[test]
    fn test_image_hash_shape() {
        // Arrange
        let hash = ImageHash {
            matrix: vec![vec![false, true], vec![true, false]],
        };

        let expected = (2, 2);

        // Act
        let flattened = hash.shape();

        // Assert
        assert_eq!(flattened, expected);
    }

    // ENCODING

    #[test]
    fn test_image_hash_encoding() {
        // Arrange

        // -> resulting bit str: 0010 0100 1111 0000
        // -> resulting hex str: 24F0
        let hash = ImageHash {
            matrix: vec![
                vec![false, false, true, false],
                vec![false, true, false, false],
                vec![true, true, true, true],
                vec![false, false, false, false],
            ],
        };

        // Assert
        assert_eq!(hash.encode(), "24f0");
    }

    #[test]
    fn test_image_hash_encoding_with_non_square_matrix() {
        // Arrange

        // -> resulting bit str: 0110 1010 0011 1110 0001
        // -> resulting hex str: 6A3E1
        let hash = ImageHash {
            matrix: vec![
                vec![false, true, true, false, true],
                vec![false, true, false, false, false],
                vec![true, true, true, true, true],
                vec![false, false, false, false, true],
            ],
        };

        // Assert
        assert_eq!(hash.encode(), "6a3e1");
    }

    #[test]
    fn test_image_hash_encoding_with_uneven_total_bits() {
        // Arrange

        // due to the uneven number of bits, the entire bit string gets padded until
        // it is divisible by 4
        // -> resulting bit str: 0011 0101 0001 1111
        // -> resulting hex str: 351F
        let hash = ImageHash {
            matrix: vec![
                vec![false, true, true, false, true],
                vec![false, true, false, false, false],
                vec![true, true, true, true, true],
            ],
        };

        // Assert
        assert_eq!(hash.encode(), "351f");
    }

    #[test]
    #[should_panic(expected = "Cannot encode an empty matrix")]
    fn test_image_hash_encoding_with_empty_matrix() {
        // Arrange
        let hash = ImageHash { matrix: vec![] };

        // Assert
        hash.encode(); // <- should panic
    }

    #[test]
    fn test_image_hash_python_safe_encoding_with_single_bit() {
        // Arrange

        // should equal to 1 due to added padding
        // -> resulting bit str: 0001
        // -> resulting hex str: 1
        let hash = ImageHash {
            matrix: vec![vec![true]],
        };

        // Assert
        assert_eq!(hash.encode(), "1");
    }

    // DECODING

    #[test]
    fn test_image_hash_decoding() {
        // Arrange
        let expected = vec![
            vec![false, false, true, false],
            vec![false, true, false, false],
            vec![true, true, true, true],
            vec![false, false, false, false],
        ];

        // Act
        let decoded = ImageHash::decode("24f0", 4, 4).unwrap();

        // Assert
        assert_eq!(decoded.matrix, expected);
    }

    #[test]
    fn test_image_hash_decoding_with_non_square_matrix() {
        // Arrange
        let expected = vec![
            vec![false, true, true, false, true],
            vec![false, true, false, false, false],
            vec![true, true, true, true, true],
            vec![false, false, false, false, true],
        ];

        // Act
        let decoded = ImageHash::decode("6a3e1", 5, 4).unwrap();

        // Assert
        assert_eq!(decoded.matrix, expected);
    }

    #[test]
    fn test_image_hash_decoding_with_uneven_total_bits() {
        // Arrange
        let expected = vec![
            vec![false, true, true, false, true],
            vec![false, true, false, false, false],
            vec![true, true, true, true, true],
        ];

        // Act
        let decoded = ImageHash::decode("351f", 5, 3).unwrap();

        // Assert
        assert_eq!(decoded.matrix, expected);
    }

    #[test]
    fn test_image_hash_decoding_with_single_bit() {
        // Arrange
        let expected = vec![vec![true]];

        // Act
        let decoded = ImageHash::decode("1", 1, 1).unwrap();

        // Assert
        assert_eq!(decoded.matrix, expected);
    }

    #[test]
    fn test_image_hash_decoding_with_too_short_string() {
        // Act
        let decoded = ImageHash::decode("AB", 2, 5);

        // Assert
        match decoded {
            Ok(_) => panic!("Should not have decoded"),
            Err(e) => assert_eq!(e, "String is too short or too long for the specified size"),
        }
    }

    #[test]
    fn test_image_hash_decoding_with_too_long_string() {
        // Act
        let decoded = ImageHash::decode("ABCD", 2, 2);

        // Assert
        match decoded {
            Ok(_) => panic!("Should not have decoded"),
            Err(e) => assert_eq!(e, "String is too short or too long for the specified size"),
        }
    }

    #[test]
    fn test_image_hash_decoding_with_invalid_string() {
        // Act
        let decoded = ImageHash::decode("!", 2, 2);

        // Assert
        match decoded {
            Ok(_) => panic!("Should not have decoded"),
            Err(e) => assert_eq!(e, "invalid digit found in string"),
        }
    }

    #[test]
    fn test_image_hash_decoding_with_zero_size_matrix() {
        // Act
        let decoded = ImageHash::decode("!", 2, 0);

        // Assert
        match decoded {
            Ok(_) => panic!("Should not have decoded"),
            Err(e) => assert_eq!(e, "Width or height cannot be 0"),
        }
    }

    #[test]
    fn test_image_hash_decoding_with_empty_string() {
        // Act
        let decoded = ImageHash::decode("", 2, 2);

        // Assert
        match decoded {
            Ok(_) => panic!("Should not have decoded"),
            Err(e) => assert_eq!(e, "String is empty"),
        }
    }

    // DISTANCE

    #[test]
    fn test_image_hash_distance_with_unequal_hashes() {
        // Arrange
        let hash1 = ImageHash {
            matrix: vec![vec![false, true], vec![true, false]],
        };

        let hash2 = ImageHash {
            matrix: vec![vec![true, true], vec![false, false]],
        };

        // Act
        let distance = hash1.distance(&hash2);

        // Assert
        match distance {
            Ok(d) => assert_eq!(d, 2),
            Err(_) => panic!("Should not have errored"),
        }
    }

    #[test]
    fn test_image_hash_distance_with_equal_hashes() {
        // Arrange
        let hash1 = ImageHash {
            matrix: vec![vec![false, true], vec![true, false]],
        };

        let hash2 = ImageHash {
            matrix: vec![vec![false, true], vec![true, false]],
        };

        // Act
        let distance = hash1.distance(&hash2);

        // Assert
        match distance {
            Ok(d) => assert_eq!(d, 0),
            Err(_) => panic!("Should not have errored"),
        }
    }

    #[test]
    fn test_image_hash_distance_with_different_sizes() {
        // Arrange
        let hash1 = ImageHash {
            matrix: vec![vec![false, true, false], vec![true, false, false]],
        };

        let hash2 = ImageHash {
            matrix: vec![vec![false, true], vec![true, false]],
        };

        // Act
        let distance = hash1.distance(&hash2);

        // Assert
        match distance {
            Ok(_) => panic!("Should not have succeeded"),
            Err(e) => assert_eq!(e, "Cannot compute distance of hashes with different sizes"),
        }
    }
}
